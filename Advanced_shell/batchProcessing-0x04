#!/usr/bin/env sh
# Parallel PokÃ©mon fetch: runs requests in background and waits for all.
# Requires: curl, jq

set -eu

API_BASE="https://pokeapi.co/api/v2/pokemon"
OUT_DIR="pokemon_data"
ERR_FILE="batch_errors.txt"

# Default list (lowercase)
POKEMON="bulbasaur ivysaur venusaur charmander charmeleon"

timestamp() { date +"%Y-%m-%d %H:%M:%S"; }

mkdir -p "$OUT_DIR"
: > "$ERR_FILE"  # truncate previous errors

fetch_one() {
  name="$1"
  url="$API_BASE/$name"
  tmp="$(mktemp)"
  tries=0
  max=3
  delay=1

  echo "Fetching data for $name..."

  while :; do
    tries=$((tries+1))

    status="$(curl -sS \
      -H "User-Agent: ALXprodev-Devops/1.2 (+pokeapi-parallel)" \
      -w "%{http_code}" -o "$tmp" "$url" 2>>"$ERR_FILE" || echo "000")"

    if [ "$status" = "200" ] && jq -e . "$tmp" >/dev/null 2>>"$ERR_FILE"; then
      mv "$tmp" "$OUT_DIR/$name.json"
      echo "Saved data to $OUT_DIR/$name.json âœ…"
      return 0
    fi

    # Non-retryable client errors (except 429)
    if [ "$status" != "000" ] && [ "$status" -ge 400 ] && [ "$status" -lt 500 ] && [ "$status" != "429" ]; then
      echo "$(timestamp) [ERROR] $name failed (HTTP $status). Not retrying." >> "$ERR_FILE"
      rm -f "$tmp"
      return 1
    fi

    # Retryable/network errors
    if [ "$tries" -ge "$max" ]; then
      echo "$(timestamp) [ERROR] $name failed after $tries tries (HTTP $status)." >> "$ERR_FILE"
      rm -f "$tmp"
      return 1
    fi

    # Backoff for 429/5xx/network issues
    sleep "$delay"
    delay=$((delay*2))
  done
}

# Launch all in background
pids=""
for name in $POKEMON; do
  fetch_one "$name" &
  pids="$pids $!"
done

# Wait for all and count failures
failures=0
for pid in $pids; do
  if ! wait "$pid"; then
    failures=$((failures+1))
  fi
done

# Summary
if [ "$failures" -gt 0 ]; then
  echo "Completed with $failures failure(s). See $ERR_FILE."
  exit 1
else
  echo "All PokÃ©mon fetched successfully in parallel ðŸŽ‰"
fi
